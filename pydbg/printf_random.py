import pydbg
# from pydbg.defines import *

import struct
import random

# user defined callback function
def printf_randomizer(dbg):
    
    # read in the value of the counter at ESP + 0x8 as a DWORD
    parameter_addr = dbg.context.Esp + 0x8
    counter = dbg.reaad_process_memory(parameter_addr, 4)

    # when using read_process_memory, returns a packed binary string
    # must unpack before using
    counter = struct.unpack("L", counter)[0]
    print "Counter: %d".format(int(counter))

    # generate a random number and pack it into binary format
    # so that it is written correctly back to the process
    random_counter = random.randint(1, 100)
    random_counter = struct.pack("L", random_counter)[0]

    # swap our random number and resume process
    dbg.write_process_memory(parameter_addr, random_counter)

    return DBG_CONTINUE

# instantiate pydbg class
dbg = pydbg.pydbg()

# enter th PID of the printf_loop.py process
pid = raw_input("Enter the printf_loop.py PID: ")

# attach the debugger into the process
dbg.attach(int(pid))

# set the breakpoint with the printf_randomized function defined as a callback
printf_address = dbg.func_resolve("mscvrt", "printf")
dbg.hp_set(printf_address, description="printf_address", handler=printf_randomizer)

# resume the process
dbg.run()
