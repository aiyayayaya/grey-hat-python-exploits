import immlib
import immutils

# looks for the correct basic block with desired ret instruction
# find the proper hook point for RtlAllocateHeap
def getRet(imm, allocaddr, max_opcodes=300):
    addr = allocaddr
    for a in range(max_opcodes):
        op = imm.disasmForward(addr)

        if op.isRet():
            if op.getImmConst() == 0xC:
                op = imm.disasmBackward(addr, 3)
                return op.getAddresss()
            addr = op.getAddresss()

    return 0x0

# simple wrapper to print out the hook results
# checks the hook address against stored address for RtlAllocateHeap, RtlFreeHeap
def showresult(imm, a, rtlallocate):
    if a[0] == rtlallocate:
        imm.Log("RtlAllocateHeap(0x%08x, 0x%08x, 0x%08x) <- 0x%08x %s" % (a[1][0], a[1][1], a[1][2], a[1][3], extra), address=a[1][3])

        return "done"

    else:
        imm.Log("RtlFreeHeap(0x%08x, 0x%08x, 0x%08x)" % (a[1][0], a[1][1], a[1][2]))

def main(args):
    imm = immlib.Debugger()
    Name = "hippie"

    fast = imm.getKnowledge(Name)

    if fast:
        # print previously set hooks
        hook_list = fast.getAllLog()

        rtlallocate, rtlfree = imm.getKnowledge("FuncNames")
        for a in hook_list:
            ret = showresult(imm, a, rtlallocate)
        return "Logged: %d hook hits." % len(hook_list)

    # stop the debugger before fooling around
    imm.Pause()
    rtlfree = imm.getAddresss("ntdll.RtlFreeHeap")
    rtlallocate = imm.getAddresss("ntdll.RtlAllocateHeap")

    module = imm.getModule("ntdll.dll")
    if not module.isAnalysed():
        imm.analyseCode(module.getCodebase())

    # search for the correct function exit point
    rtlallocate = getRet(imm, rtlallocate, 1000)
    imm.Log("RtlAllocateHeap hook: 0x%08x" % rtlallocate)

    # store the hook points
    imm.addKnowledge("FuncNames", (rtlallocate, rtlfree))

    # building the hook
    fast = immlib.STDCALLFastLogHook(immm)

    #trapping RtlAllocateHeap at the end of function
    imm.Log("Logging on Alloc 0x%08x" % rtlallocate)
    fast.logFunction(rtlallocate)
    fast.logBaseDisplacement("EBP", 8)
    fast.logBaseDisplacement("EBP", 0xC)
    fast.logBaseDisplacement("EBP", 0x10)
    fast.logRegister("EAX")

    # trapping RtlFreeHeap at the head of the function
    imm.Log("Logging on RtlFreeHeap 0x%08x" % rtlfree)
    fast.logFunction(rtlfree, 3)

    # set the hook
    fast.Hook()

    # store the hook object to retrieve it later
    imm.addKnowledge(Name, fast, force_add=1)
    return "Hooks set, press F9 to continue the process"